RabbitMQ是基于AMQP协议来实现的消息中间件。AMQP，类似于HTTP协议，也是一个应用层的协议，网络层使用TCP来通信。
Client要与Server进行通信，就必须先建立连接，RabbitMQ中有Connection与Channel两个概念，前者就是一个TCP连接，后者是在这个连接上的虚拟概念，负责逻辑上
的数据传递，为了节省资源，一般在一个客户端中建立一个Connection，每次使用时再分配一个Channel。

所谓模式就是在某种场景下，一类问题及其解决方案的总结归纳。
生产消费者模式与订阅发布模式是使用消息中间件时常用的两种模式，用于功能解耦和分布式系统间的消息通信。
不同于HTTP的同步访问，在RabbitMQ中是异步处理的，通过 消息确认机制和 数据持久化确保投递可靠性。

数据接入
  假设有一个用户行为采集系统，负责从客户端采集用户数据。
  通常会将数据上报和数据处理分离开，即客户端通过API上报数据，后端拿到数据后放入队列中就立刻返回，而数据处理则使用Worker进程从队列中取出数据来做。
  这样做的好处：
  1.功能分离，上报的API接口不关心数据处理功能，只负责接入数据
  2.数据缓冲，数据上报的速率是不可控的，取决于用户使用频率，采用该模式可以一定程度地缓冲数据
  3.易于扩展，在数据量大时，通过增加数据处理Worker进程来扩展，提高处理速率

事件分发 
  假设有一个电商系统，用户“收藏”、“下单”、“付款”等行为都是非常重要的事件，通常后端服务在完成相应的功能处理外，还需要在这些事件点上做很多其他处理动作，
  比如发送短信通知、记录用户积分等等。我们可以将这些额外的处理动作放到每个模块中，但这并不是优雅的实现，不利于功能解耦和代码维护。 
  我们需要一个事件分发系统，在各个功能模块中将对应的事件发布出来，由对其感兴趣的处理者进行处理。
  这里涉及两个角色：A对B感兴趣，A是处理者，B是事件，由事件处理器完成二者的绑定，并向消息中心订阅事件。
  服务模块是后端的业务逻辑服务，在不同的事件点发布事件，事件经过消息中心分发给事件处理器对应的处理者。

订阅发布模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。
而生产者消费者关系可以是1对1，1对多，多对1，多对多关系
 
举个例子，面试完之后每个面试官都会对我们说：“我们会综合考虑您的情况，有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。
所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。



